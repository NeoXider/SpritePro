# Документация модуля Animation

Модуль Animation предоставляет расширенные возможности анимации для спрайтов в рамках SpritePro.

## Обзор

Класс Animation - это мощный компонент, который обеспечивает покадровую анимацию, плавные переходы и параллельные анимации для спрайтов. Он поддерживает различные состояния анимации, обратные вызовы и эффекты плавного перехода.

## Основные возможности

- Покадровая анимация с настраиваемой длительностью кадра
- Управление различными состояниями анимации
- Плавные переходы с использованием твининга
- Поддержка параллельных анимаций
- Система обратных вызовов для событий анимации
- Режимы зацикливания и однократного воспроизведения

## Класс: Animation

### Конструктор
```python
Animation(
    owner_sprite,
    frames: Optional[List[pygame.Surface]] = None,
    frame_duration: int = 100,
    loop: bool = True,
    on_complete: Optional[Callable] = None,
    on_frame: Optional[Callable] = None
)
```

### Свойства
- `owner`: Спрайт-владелец анимации
- `frames`: Список кадров анимации
- `frame_duration`: Длительность каждого кадра в миллисекундах
- `loop`: Зациклена ли анимация
- `current_frame`: Индекс текущего кадра
- `is_playing`: Воспроизводится ли анимация
- `is_paused`: На паузе ли анимация

### Методы

#### Управление состоянием
- `add_state(name: str, frames: List[pygame.Surface])`: Добавить новое состояние анимации
- `set_state(name: str)`: Переключиться на другое состояние анимации

#### Управление воспроизведением
- `play()`: Начать воспроизведение анимации
- `pause()`: Поставить анимацию на паузу
- `resume()`: Возобновить анимацию
- `stop()`: Остановить анимацию
- `reset()`: Сбросить анимацию в начальное состояние

#### Твининг
- `add_tween(name: str, start_value: float, end_value: float, duration: float, ...)`: Добавить плавный переход
- `update_tween(name: str, dt: Optional[float] = None)`: Обновить конкретный переход

#### Параллельные анимации
- `add_parallel_animation(animation: Animation)`: Добавить анимацию для параллельного выполнения

#### Управление кадрами
- `update(dt: Optional[float] = None)`: Обновить состояние анимации
- `get_current_frame() -> Optional[pygame.Surface]`: Получить текущий кадр анимации
- `set_frame_duration(duration: int)`: Установить длительность кадра
- `set_loop(loop: bool)`: Установить зацикливание анимации

## Примеры использования

### Базовая анимация
```python
# Создание спрайта
sprite = Sprite("", (100, 100), (400, 300))

# Создание кадров анимации
frames = []
for i in range(8):
    frame = pygame.Surface((100, 100), pygame.SRCALPHA)
    # Нарисовать что-то на кадре
    frames.append(frame)

# Создание и запуск анимации
animation = Animation(sprite, frames=frames, frame_duration=100)
animation.play()
```

### Анимация с состояниями
```python
# Создание анимации с состояниями
animation = Animation(sprite)
animation.add_state("idle", idle_frames)
animation.add_state("walk", walk_frames)

# Переключение состояний
animation.set_state("walk")
```

### Анимация с твинингом
```python
# Добавление твина масштаба
animation.add_tween(
    "scale",
    start_value=1.0,
    end_value=1.5,
    duration=1.0,
    easing=EasingType.EASE_IN_OUT,
    loop=True,
    yoyo=True
)
```

## Рекомендации

1. **Управление кадрами**
   - Поддерживайте одинаковый размер кадров
   - Используйте подходящую длительность кадров
   - Учитывайте использование памяти при большом количестве кадров

2. **Управление состоянием**
   - Используйте осмысленные имена состояний
   - Загружайте все состояния при инициализации
   - Обеспечивайте плавные переходы между состояниями

3. **Производительность**
   - Используйте оптимальное количество кадров
   - Рассмотрите использование спрайт-листов для сложных анимаций
   - Следите за использованием памяти при множественных анимациях

4. **Твининг**
   - Используйте подходящие типы плавности
   - Учитывайте влияние на производительность при множественных твинах
   - Используйте эффект йо-йо для плавных переходов 