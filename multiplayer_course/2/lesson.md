# Урок 2. Синхронизация позиции

## Цель
- Синхронизировать движение двух игроков.
- Научиться ограничивать частоту отправки сообщений.
- Отделять локальное управление от сетевого состояния.

## Требования
- Python 3.7+
- spritePro доступен в проекте

## Теория (кратко)
- Нет смысла отправлять состояние каждый кадр.
- Удобно держать таймер отправки и посылать 10–20 раз в секунду.
- Входящие данные читаются через `net.poll()` внутри игрового цикла.

## EventBus и прямые сообщения
- Для частых данных (позиции) здесь используется `ctx.send_every()` и `ctx.poll()`.
- EventBus удобен для дискретных событий (ready, start, shoot) — пример в уроке 3: `example_ready_state_events.py`.
- EventBus не заменяет сетевой слой, это удобная надстройка с подписчиками.

## Практика
1. Запустите `example_sync_positions.py`.
1. Убедитесь, что оба окна отображают движение друг друга.
1. Посмотрите, где ограничивается частота отправки.

## Вопросы для самопроверки
- Почему отправка каждый кадр вредна?
- Что будет, если `poll()` вызывать редко?
- Какие поля удобно передавать вместе с позицией?

## Задания
- В `practice_sync_positions.py` добавьте отправку позиции и прием данных.
- Убедитесь, что второй игрок движется плавно.

## Решение
- См. `solution_sync_positions.py`.

## Что еще изучить
- Интерполяция и сглаживание движения.
- Авторитетный сервер и базовая валидация.
