# Урок 10. Роутинг событий, лучшие практики и куда двигаться дальше

## Цель
- Понять варианты доставки событий: только сервер, только клиенты, всем.
- Уяснить, почему не стоит всегда слать «всем».
- Закрепить лучшие практики мультиплеера в SpritePro.
- Наметить направления для дальнейшего изучения.

## Требования
- Python 3.7+
- spritePro доступен в проекте
- Пройдены уроки 1–3 (желательно и 4–6).

---

## Теория: куда можно отправлять события

В EventBus и при прямой отправке через контекст можно разделять **куда** уходит сообщение.

### Варианты роутинга (EventBus: `route=...`)

| route    | Локально (подписчики на этом процессе) | Сеть (на сервер) | Кто в итоге получит при текущем relay |
|----------|----------------------------------------|-------------------|---------------------------------------|
| `local`  | да                                     | нет               | только этот процесс                   |
| `all`    | да                                     | да                | этот процесс + все остальные (relay рассылает всем кроме отправителя) |
| `server` | нет                                    | да                | сервер получает; при relay сервер пересылает всем — т.е. как «в сеть» |
| `clients`| нет                                    | да                | то же в текущем relay                 |
| `net`    | нет                                    | да                | то же в текущем relay                 |

В **текущем relay-сервере** SpritePro сервер просто пересылает каждое сообщение всем клиентам (кроме отправителя). Поэтому с точки зрения «кто получит» варианты `server` / `clients` / `all` (сеть) сейчас ведут себя одинаково: все остальные получат. Разница в том:

- **local** — только свои подписчики, в сеть ничего не уходит.
- **all** — свои подписчики вызываются **и** сообщение уходит в сеть (удобно для «сделал действие — обнови себя и всех»).
- **server** / **clients** / **net** — в сеть уходит, локальные подписчики по умолчанию не вызываются (удобно, когда «только сервер должен обработать» или «не дублировать локальный вызов»).

В игре с **авторитетным сервером** семантика была бы другая: «server» — только сервер обрабатывает и сам решает, кому рассылать; «clients» — сервер не обрабатывает, только пересылает клиентам. Для курса важно привыкнуть к выбору маршрута по смыслу.

### Когда что использовать

- **Только локально (`local`)**  
  События, которые не должны уходить в сеть: локальный UI, отладочные логи, предпросмотр.

- **Всем (`all`)**  
  События, которые должны и у себя примениться, и у всех: готовность (ready), старт (start), выстрел (shoot), чат. Отправитель сразу видит своё действие и рассылает его остальным.

- **Только на сервер (смысл `server`)**  
  Запросы к серверу: «засчитай очко», «запроси список комнат», heartbeat. Сервер решает, обновлять ли состояние и кому рассылать (в нашем relay он пока просто рассылает всем).

- **Только клиентам (смысл `clients`)**  
  Когда серверу не нужно обрабатывать событие, а только переслать другим клиентам (в текущем relay так и так всё пересылается).

---

## Почему нежелательно всегда отправлять «всем»

1. **Трафик и шум**  
   Не каждое событие нужно каждому. Например, «игрок вошёл в меню настроек» не обязательно слать всем; «игрок нажал ready» — да.

2. **Безопасность и доверие**  
   Если клиент будет слать «я набрал 10 очков» всем напрямую, другие поверят без проверки. Правильнее: клиент шлёт «я попал в зону» только серверу/хосту; хост считает очки и рассылает уже итог (score_update). Так «всем» получают только авторизованное состояние.

3. **Логика и авторитет**  
   Кто решает исход (счёт, победа, валидация) — тот и рассылает результат. Клиенты шлют **заявки** (score, hit), хост/сервер шлёт **итог** (score_update, game_over). Если всё слать «всем» подряд, размывается, кто источник истины.

4. **Дублирование и баги**  
   При `route="all"` у отправителя срабатывают локальные подписчики. Если ещё и слать «всем» то, что должно обрабатывать только на сервере, легко получить двойное начисление очков или разное состояние у разных клиентов.

Итого: «всем» — для событий, которые по смыслу общие (ready, start, чат). Для заявок на изменение состояния и служебных вещей — предпочтительно «только сервер» (или хост), а результат уже рассылать всем.

---

## Лучшие практики (кратко)

1. **Один источник истины для состояния**  
   Счёт, список игроков, победитель — хранит и рассылает хост (или сервер). Клиенты шлют только события («я попал в зону», «готов»).

2. **Троттлинг частых данных**  
   Позиции, повороты — не каждый кадр, а `send_every("pos", data, interval)` или по тикрейту.

3. **Готовность и старт**  
   Готовность шлём всем (или на сервер); старт инициирует только хост и рассылает всем.

4. **Имена событий и контракт data**  
   Чёткие имена (`ready`, `start`, `score`, `score_update`, `game_over`) и стабильный формат `data`, чтобы все клиенты обрабатывали одинаково.

5. **Локальное обновление отправителя**  
   Сервер не шлёт копию отправителю (exclude). Поэтому при отправке ready/start обновляйте свою ячейку в ready_map сами (или используйте route="all", тогда локальный обработчик сработает).

6. **EventBus vs прямой send**  
   EventBus — для дискретных событий (ready, start, shoot), удобно подписывать несколько систем. Прямой `ctx.send()` / `send_every()` — для частых потоков (позиции), меньше оверхеда.

7. **Роутинг по смыслу**  
   Даже если в текущем relay всё уходит «всем», сразу привыкайте: заявки — к серверу/хосту, итог — от хоста всем; локальные вещи — `local`.

---

## Практика

1. Запустите `example_routing.py`: в консоли видно, какие события куда отправляются (локально, в сеть).
2. В `practice_routing.py` выполните задания по роутингу и выбору «кто шлёт кому».
3. Подумайте над уроками 6–7: почему клиент шлёт `score`, а хост шлёт `score_update`? Что было бы, если бы клиент слал `score_update` всем?

---

## Задания (practice_routing.py)

1. **Роутинг по смыслу**  
   Добавьте отправку события `ping` только на сервер (route="server") раз в 2 секунды и событие `emoji` всем (route="all") по нажатию клавиши. В комментарии напишите, зачем разный маршрут.

2. **Кто рассылает итог**  
   В одном-двух предложениях (в комментарии или в lesson.md): почему в игре со счётом хост рассылает `score_update`, а не каждый клиент сам шлёт «счёт» всем?

3. **Лучшая практика**  
   В примере с лобби (урок 4): кто должен рассылать `roster` — хост или все? Обоснуйте в комментарии в коде (в practice можно просто написать ответ в docstring).

---

## Решение
- См. `solution_routing.py`.

---

## Куда двигаться дальше

- **Интерполяция и сглаживание**  
  Позиции приходят дискретно; на клиенте можно интерполировать между последними двумя пакетами, чтобы движение «чужого» игрока выглядело плавно.

- **Предсказание на клиенте**  
  Локально двигать своего игрока сразу, сервер периодически присылает авторитетное состояние и при расхождении можно корректировать (или принимать серверное значение).

- **Авторитетный сервер**  
  Сервер хранит состояние игры (позиции, счёт), валидирует действия (попал ли в зону, не читер ли), рассылает только валидные обновления. Клиенты шлют только ввод/заявки.

- **Защита от читов**  
  Не доверять клиенту в вопросах счёта, победы, скорости; проверки на сервере и анти-спам (кулдауны, лимиты).

- **Более сложный сетевой стек**  
  UDP для позиций, отдельные каналы, сжатие, битовая упаковка — когда прототип перерастает в продакшен.

- **Другие движки и фреймворки**  
  Unity Netcode, Mirror, Photon, собственный сервер на asyncio/Node — те же идеи (авторитет, роутинг, троттлинг) переносятся на другие технологии.
