# Networking

Минимальный сетевой слой SpritePro для прототипов мультиплеера.  
Основан на TCP и протоколе «одна строка JSON = одно сообщение».

## Когда это использовать

- Быстрые прототипы, локальные и небольшие онлайн‑демо.
- Простая синхронизация позиций, состояний, событий.
- Когда важнее скорость разработки, чем продвинутая сетевой архитектура.

## Базовые понятия

Сообщение — это JSON‑объект с двумя полями:

```json
{"event": "pos", "data": {"x": 10, "y": 20}}
```

- `event` — строковый идентификатор события.
- `data` — словарь произвольных данных.

## Компоненты

### NetServer

TCP‑сервер, который принимает клиентов и по умолчанию пересылает сообщения всем.

- `NetServer(host="0.0.0.0", port=5050, relay=True, debug=None, name="server")`
- `start()` — запуск сервера в отдельном потоке.
- `poll(max_messages=100)` — забирает входящие сообщения.
- `broadcast(event, data)` — отправляет сообщение всем клиентам.
- `stop()` — останавливает сервер.

### NetClient

TCP‑клиент, который отправляет сообщения и получает их через очередь.

- `NetClient(host, port=5050, debug=None, name="client")`
- `connect()` — подключение к серверу.
- `send(event, data)` — отправка сообщения.
- `poll(max_messages=100)` — забирает входящие сообщения.
- `close()` — закрывает соединение.

### s.networking.run(...)

Утилита запуска для быстрого мультиплеера с автозапуском клиента/серверов.

```python
s.networking.run(
    argv=None,
    entry="multiplayer_main",
    host="127.0.0.1",
    port=5050,
    clients=2,
    net_debug=False,
    client_spawn_delay=0.0,
)
```

Важно: `run()` нужно вызывать из файла, а не из REPL.

Можно задать число клиентов прямо из кода (в `--quick` это общее число окон: хост + клиенты):

```python
s.networking.run(clients=3)  # 3 окна: host + 2 клиента
```

Окна в режимах `--host_mode` и `--quick` автоматически разводятся по экрану.
Если нужно вручную — установите переменную окружения:

```bash
SPRITEPRO_WINDOW_POS=100,100
```

## Быстрый старт (в 2 окна)

1. Запустить демо в быстрый режим:

```bash
python spritePro/demoGames/local_multiplayer_demo.py --quick --host 127.0.0.1 --port 5050
```

1. Появится окно хоста и окно второго клиента.

## Минимальный пример: сервер и клиент

### Сервер

```python
import spritePro as s

server = s.NetServer(host="0.0.0.0", port=5050)
server.start()

while True:
    for msg in server.poll():
        print("server msg:", msg)
```

### Клиент

```python
import spritePro as s

net = s.NetClient("127.0.0.1", 5050)
net.connect()

net.send("hello", {"name": "player"})
for msg in net.poll():
    if msg.get("event") == "hello":
        print("client msg:", msg.get("data"))
```

## Пример: синхронизация позиции

```python
import pygame
import spritePro as s

net = s.NetClient("127.0.0.1", 5050)
net.connect()

my_color = (220, 70, 70)
other_color = (70, 120, 220)
me = s.Sprite("", (40, 40), (200, 300))
me.set_color(my_color)
other = s.Sprite("", (40, 40), (600, 300))
other.set_color(other_color)
remote_pos = [600.0, 300.0]

while True:
    s.update(fill_color=(20, 20, 25))
    dt = s.dt

    dx = s.input.get_axis(pygame.K_a, pygame.K_d)
    dy = s.input.get_axis(pygame.K_w, pygame.K_s)
    pos = me.get_world_position()
    pos.x += dx * 240.0 * dt
    pos.y += dy * 240.0 * dt
    me.set_position(pos)

    net.send("pos", {"x": pos.x, "y": pos.y})
    for msg in net.poll():
        if msg.get("event") == "pos":
            data = msg.get("data", {})
            remote_pos[:] = [float(data.get("x", remote_pos[0])), float(data.get("y", remote_pos[1]))]
    other.set_position(remote_pos)
```

## Интеграция через s.networking.run()

Создайте функцию входа и вызовите `run()`:

```python
import pygame
import spritePro as s

def multiplayer_main(net: s.NetClient, role: str):
    s.get_screen((800, 600), "My Multiplayer")
    ctx = s.multiplayer.init_context(net, role)
    me = s.Sprite("", (40, 40), (200, 300))
    me.set_color((220, 70, 70) if ctx.is_host else (70, 120, 220))

    while True:
        s.update(fill_color=(20, 20, 25))
        pos = me.get_world_position()
        net.send("pos", {"x": pos.x, "y": pos.y})

s.networking.run()
```

Если функция называется иначе:

```python
s.networking.run(entry="module:function")
```

## Режимы запуска run()

- `--server` — только сервер.
- `--host_mode` — сервер + клиент в одном процессе.
- `--quick` — быстрый запуск (хост + второй клиент).
- `--host` / `--port` — адрес и порт.
- `--clients` — общее число окон в quick (хост + клиенты).
- `--entry` — функция входа (`multiplayer_main` или `module:function`).
- `--tick_rate` — тикрейт сервера (только для режима `--server`, по умолчанию 30).
- `--net_debug` — сетевой debug в консоль.
- `--client_spawn_delay` — задержка (сек) перед запуском каждого клиента в `--quick`.

Пример изменения тикрейта сервера:

```bash
python your_game.py --server --tick_rate 20
```

## Типовая схема работы

1. Клиент отправляет входные данные или состояние (`event="input"` или `event="pos"`).
1. Сервер принимает и пересылает сообщения всем участникам (relay).
1. Клиенты применяют обновления в своей игровой логике.

Рекомендуется:

- Отправлять сообщения 10–20 раз в секунду, а не каждый кадр.
- Использовать `poll()` в каждом игровом тике, чтобы не копить очередь.
- Отдельно синхронизировать события (`shoot`, `hit`, `start`) и состояние.

## Частые ошибки и советы

- `host="0.0.0.0"` — только для сервера (bind), клиент должен подключаться к IP.
- Не забывайте вызывать `net.connect()` до `send()`.
- `run()` не работает в интерактивной консоли — нужен файл.
- Если `poll()` не вызывается, сообщения копятся в очереди.

## Лучшие практики

### Что можно отправлять по сети (примитивы JSON)

Сообщения сериализуются в **JSON**. В `data` можно передавать только то, что умеет JSON:

- **Числа** — `int`, `float`
- **Строки** — `str`
- **Списки и словари** — вложенные структуры из перечисленного
- **Булевы** — `True` / `False`
- **Пусто** — `None` (в JSON будет `null`)

Объекты вроде `Vector2`, спрайтов, классов — **нельзя** отправлять как есть. Конвертируйте в примитивы: позиция → `list(pos)` или `[pos.x, pos.y]`, состояние → `dict` с полями. На приёме вы получаете уже числа/списки/словари — приводить к `float()` не нужно.

### Позиция удалённого игрока: один список, обновление на месте

Один список на удалённую позицию и обновление через срез — не пересоздаём объект и не теряем ссылку для `set_position()`. Позицию удобно отправлять списком: на приёме одно присваивание. `get_world_position()` возвращает `Vector2`; он итерируем, поэтому подойдёт `list(pos)`:

```python
# Отправка: pos — Vector2 из get_world_position(), list(pos) → [x, y]
ctx.send_every("pos", {"pos": list(pos)}, 0.05)

# Приём: один буфер, обновляем на месте
remote_pos = [x0, y0]
for msg in ctx.poll():
    if msg.get("event") == "pos":
        data = msg.get("data", {})
        remote_pos[:] = data.get("pos", [0, 0])
other.set_position(remote_pos)
```

По умолчанию при отсутствии ключа можно подставить предыдущее значение: `data.get("pos", remote_pos)` — тогда при пропуске пакета позиция не дёрнется. Вариант с полями `{"x": pos.x, "y": pos.y}` тоже допустим; на приёме тогда `remote_pos[:] = [data.get("x", 0), data.get("y", 0)]`.

### Данные из JSON — уже нужные типы

После `json.loads` поля приходят как числа, строки, списки, словари. Приводить к `float()` или `int()` вручную не нужно — используйте значения как есть: `data.get("x", 0)`, `data.get("sender_id")`.

### Значения по умолчанию при разборе payload

- `data.get("key", default)` — если ключа нет или событие пришло без поля, подставится `default`. Для позиции удобны `0` или текущее значение (`remote_pos[0]`).
- Для вложенных структур: `data.get("scores", self.scores)` — не перезаписываем локальное состояние, если в сообщении пусто.
- Если вы сами всегда отправляете полный payload (например, `pos` с `x`, `y`, `sender_id`), на приёме можно не проверять на `None` — присваивайте `other_id = data.get("sender_id")` и при отображении обработайте `other_id is None` (например, показать «?»).

### Троттлинг позиции

Используйте `ctx.send_every("pos", {"pos": list(pos)}, interval)` вместо `ctx.send("pos", ...)` в каждом кадре — так вы ограничите частоту отправки (например, 20 раз/сек при `interval=0.05`) и снизите нагрузку на сеть.

## Debug‑режим мультиплеера (консоль)

Включите вывод отправки/получения сообщений:

```python
server = s.NetServer(debug=True)
client = s.NetClient("127.0.0.1", 5050, debug=True)
```

Или при запуске:

```bash
python your_game.py --net_debug
```

Логи выводятся в консоль. Дополнительно при использовании `run()` или при заданной переменной окружения `SPRITEPRO_NET_LOG_TAG` сетевые сообщения пишутся в файлы в каталоге **spritepro_logs/** (создаётся рядом со скриптом): `debug_net_<tag>.log` с тегами `host`, `client_0`, `client_1` и т.д. В строках лога указывается callsite. Критические ошибки (FATAL) дублируются в этот файл и в `s.debug_log_error`. Вывод в оверлей — через `net_log_to_overlay()`.

## MultiplayerContext (глобальный контекст)

Чтобы не создавать вручную глобальные переменные `NET/ROLE`,
используйте контекст:

```python
import spritePro as s

def multiplayer_main(net: s.NetClient, role: str):
    _ = s.multiplayer.init_context(net, role, debug=False)
    ctx = s.multiplayer_ctx
    # ctx.send("ready", {...})
    # for msg in ctx.poll(): ...

s.networking.run()
```

### Кто такой «этот процесс» (наш компьютер)

Код `multiplayer_main` выполняется **в одном из процессов** — в том же окне, что открылось при запуске. Этот процесс и есть «наш компьютер»: мы не «получаем» его с сервера, мы в нём уже находимся. Чтобы понять, хост мы или клиент и какой у нас номер, используйте поля контекста после `init_context()`.

### Поля контекста и возможные значения

| Поле / метод | За что отвечает | Возможные значения |
|--------------|-----------------|--------------------|
| `ctx.client_id` | Числовой ID этого участника. Уникален в сессии. | `0` — хост; `1`, `2`, … — клиенты (назначаются сервером по порядку подключения). |
| `ctx.role` | Роль процесса в сети. | `"host"` — процесс с поднятым сервером (одно окно); `"client"` — обычный клиент; `"server"` — только сервер без игры (контекст не создаётся). |
| `ctx.is_host` | Является ли этот процесс хостом. | `True` — мы хост, `False` — мы клиент. Удобно для ветвления логики («если хост — рассылаю roster»). |
| `ctx.state` | Произвольный словарь для глобального состояния. | Любой dict, общий на весь процесс. |
| `ctx.seed` / `ctx.random` | Детерминированный рандом для мультиплеера. | См. раздел «Детерминированный рандом». |
| `ctx.send(event, data)` | Отправка сообщения в сеть. | — |
| `ctx.poll()` | Получение входящих сообщений. | Список dict с полями `event`, `data`. |
| `ctx.send_every(event, data, interval)` | Отправка не чаще чем раз в `interval` секунд. | — |

Роль задаётся при запуске: `run()` передаёт в `multiplayer_main` аргумент `role` в зависимости от режима (`--host_mode`, `--quick`, `--server`). Контекст только отражает уже выбранную роль.

### Отображаемое имя участника (name)

В примерах часто встречается переменная вроде `name = "host" if ctx.is_host else f"client_{client_index + 1}"`. Это **не** «получение сервера» и не данные с сети: это **локально выбранное отображаемое имя** для этого процесса (чтобы в лобби показывать «host», «client_1», «client_2»). Номер клиента для имени можно взять из `os.environ.get("SPRITEPRO_NET_INDEX", "0")` (индекс окна клиента) или строить логику по `ctx.client_id` (0 у хоста, 1 и выше у клиентов). Сервер имён не выдаёт — имя задаётся в коде под текущую роль и ID.

### Как отличить своего игрока от чужих (цвет, камера)

«Наш» экземпляр игры — это **этот процесс**: мы не получаем его по сети, мы в нём. В этом процессе один спрайт обновляется от **локального ввода** (клавиатура, мышь) и его позиция **отправляется** в сеть — это «я». Остальные спрайты обновляются из `ctx.poll()` — это «другие». Цвет задаём в коде: свой — один (например синий), чужие — другой (красный).

```python
ctx = s.multiplayer_ctx
me = s.Sprite("", (40, 40), (200, 300))    # двигаем мы, шлём позицию в сеть
other = s.Sprite("", (40, 40), (600, 300)) # позицию получаем из ctx.poll()

# В этом процессе «я» всегда один и тот же — тот, кого мы контролируем.
MY_COLOR = (70, 120, 220)    # синий
OTHER_COLOR = (220, 70, 70)  # красный
me.set_color(MY_COLOR)
other.set_color(OTHER_COLOR)

# В игровом цикле: движение me от s.input, отправка ctx.send("pos", ...);
# other.set_position(...) из данных, пришедших в ctx.poll().
```

У каждого участника в своём окне «я» синий, «другие» красные — так и задумано: в своём экземпляре игры свой персонаж выделен. Для нескольких чужих игроков храните словарь `others[client_id]` и задайте им один цвет «чужой» или разные по `client_id`.

### Детерминированный рандом

По умолчанию контекст использует фиксированный сид `1337`, чтобы у всех клиентов
случайные значения совпадали.

Если нужно задать свой сид:

```python
_ = s.multiplayer.init_context(net, role, seed=42)
ctx = s.multiplayer_ctx

# или позже
s.multiplayer.set_seed(42)

rng = s.multiplayer.get_random()
value = rng.randint(1, 10)
```

### Что такое send_every

`send_every(event, data, interval)` — это встроенный лимитер отправки.
Он гарантирует, что событие не будет отправляться чаще, чем раз в `interval` секунд.
Удобно для позиции:

```python
ctx.send_every("pos", {"x": pos.x, "y": pos.y}, 0.05)
```

## Ограничения

- Нет предсказания, компенсации лагов и валидации на сервере.
- Нет шифрования, авторизации и защиты от читов.
- Модель relay подходит для прототипов, но не для боевых игр.

Для более сложных проектов используйте собственный сетевой слой
или расширяйте текущий с авторитетным сервером и валидацией.
